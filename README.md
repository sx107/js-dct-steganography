# JS DCT steganography

Simple DCT steganography example in JS. Think of it as of a proof-of-concept, it does not hide very well.

Use your imagination on how to use this and hide data. This steganography method survives moderate JPEG compression, and at kernel sizes > 8px even picture resizing (although, you will have to correct the kernel size and position manually).

![Steganography image](python-scripts/encoded-test.png?raw=true "Title")

### Files

- **stegano.js** - main JS file with DCT steganography functions
- **example.html** - Usage example with JS code inside
- **testOriginal.png** - Test image
- **dct0.png, dct1.png** - DCT Basis images generated by a python script
- *python-scripts* - Python scripts
    - **genBasis.py** - generate dct0.png and dct1.png
	- **decode.py** - Decode steganography data
	- **encoded-test.png** - Steganography-encoded *testOriginal.png* image, saved from *example.html* output
	- **encoded-test.jpg** - Same image, but with JPEG compression
	
### Main Functions
- **bytesToDCT(inctx, dx, dy, w, h, bytes)** - Draws DCT steganography with data ***bytes*** on canvas 2d contex ***inctx*** at position ***dx, dy*** of width ***w, h*** in blocks. Uses 2 bytes per block. Draws a black background behind the DCT block. **Use this function.**
- **steganoFillRandom(array, nbytes)** - Returns a new array, filled up to ***nbytes*** length (max 255) with constant random numbers.
- **hamming48_encode(array, use_manchester)** - Returns hamming(8, 4) encoded data ***array***, processed or not with manchester encoding according to ***use_manchester***. Using manchester encoding is preferable. Remember that using hamming(4,8) encoding makes the data array twice as long.
- **hamming48_decode(array, use_manchester)** - Same, but decodes hamming/manchester encoded data.

### Settings
- const dctSize = 16 // DCT Kernel size in pixels

### Additional/helper functions

- **bytesToSingleDCT(inctx, dx, dy, bytes)** - Draws single DCT block with data ***bytes*** at position ***dx, dy*** on canvas 2d contex ***inctx***. Does not draw a black background behind the DCT block. If only one byte is passed, it repeats it twice. Theoretically, you can easily modify this function and bytesToDCT to use 4 bytes per block. **Do not use. If you need just one block, use bytesToDCT with w=1, h=1.**

### Implementation

Positive DCT coefficients are 0s, negative coefficients are 1s. Hamming(8, 4) and manchester encoding are used. The "bit order" of DCT coefficients is accodring to JPEG compression quantization from here: [How JPEG works](https://cgjennings.ca/articles/jpeg-compression/ "How JPEG works")

Encoding is implemented to be as fast as possible, therefore it uses pre-calculated DCT basis stored in *dct0.png* and *dct1.png*, which can be generated with *genBasis.py*, and then draws them with straight pixel-add blending mode. Use a separate canvas, and then draw this canvas onto target canvas with *luminocity* composite operation. See *example.html*.

Decoding is done in a python script *decode.py*, but you have to specify particular coordinates and kernel size.

This code does not implement any automatic steganography search or steganography decoding in JS (TODO). It does implement error correction and detection (up to a certain point), though. It does not automatically search where steganography data is. Preferably, use a first byte (or first two-byte) marker, and include data length information.
